<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>handbook of face recognition</title>

    <!-- Favicon -->
    <!-- {% load static %} -->
    <link rel="icon" href="static/img/favicon_2.ico">
<!-- {#    <link rel="shortcut icon" href="static/assets/media/image/favicon.png"/>#} -->
    <!-- Plugin styles -->
    <link rel="stylesheet" href="static/vendors/bundle.css" type="text/css">
    <!-- Slick -->
    <link rel="stylesheet" href="static/vendors/slick/slick.css" type="text/css">
    <link rel="stylesheet" href="static/vendors/slick/slick-theme.css" type="text/css">

    <!-- Daterangepicker -->
    <link rel="stylesheet" href="static/vendors/datepicker/daterangepicker.css" type="text/css">

    <!-- DataTable -->
    <link rel="stylesheet" href="static/vendors/dataTable/datatables.min.css" type="text/css">

    <!-- App styles -->
    <link rel="stylesheet" href="static/assets/css/app.css" type="text/css">
    <!-- {% block script_link %} -->
    <link rel="stylesheet" href="static/css/highlights/default.css">
    <link rel="stylesheet" href="static/css/pygments.css"/>
    <link rel="stylesheet" href="static/css/bootstrap.min.css">
    <script src="static/js/jquery-2.1.3.min.js" ></script>
    <style>
    h1, h2, h3{color:rgb(33,150,243)!important}
    .h1, h1 {
        font-size: 28px;
    }
    p {
        font-size: 16px;
        letter-spacing: 0;
        margin: 0 0 10px;
        font-weight: 400;
        line-height: 24px;
        display: block;
        margin-block-start: 1em;
        margin-block-end: 1em;
        margin-inline-start: 0px;
        margin-inline-end: 0px;
    }
    </style>

    <script type="text/x-mathjax-config">
        window.MathJax.Hub.Config({
            showProcessingMessages: false, //关闭js加载过程信息
            messageStyle: "none", //不显示信息
            extensions: ["tex2jax.js"],
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ], //行内公式选择符
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ], //段内公式选择符
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a'], //避开某些标签
                ignoreClass:"comment-content" //避开含该Class的标签
            },
            "HTML-CSS": {
                availableFonts: ["STIX","TeX"], //可选字体
                showMathMenu: false //关闭右击菜单显示
            }
        });
        window.MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    </script>
    <script src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" async="async" src="static/js/MathJax.js"></script>
    <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js"></script>
    <script data-no-instant>
        InstantClick.on('change', function(isInitialLoad){
            if (isInitialLoad === false) {
                if (typeof MathJax !== 'undefined'){
                    MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
                }
            }
        });
        InstantClick.init();
    </script>
<!-- <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"> -->
</script>
    <!-- {% endblock %} -->
</head>
<body>

<!-- begin::preloader-->
<!-- {#<div class="preloader">#}
{#    <div class="preloader-icon"></div>#}
{#</div>#} -->
<!-- end::preloader -->

<!-- begin::header -->
<div class="header" style="background-color: #26A69A;color: white">

    <div class="header-left">
        <div class="navigation-toggler">
            <a href="#" data-action="navigation-toggler">
                <i data-feather="menu"></i>
            </a>
        </div>
        <div class="header-logo">
            <a href="d2l.html">
<!-- {#                <img class="logo" src="{% static 'img/favicon_2.ico' %}" alt="logo">#} -->
                <img style="width: 150px;display: block" class="logo" src="static/img/d2l_nav.png" alt="logo">
<!-- {#                <img class="logo-light" src="#" alt="light logo">#} -->
            </a>
            <!-- <div style="margin:0 15%;text-align: center;z-index: 0;">
                <div class="page-title" style="text-align: center;padding: 0">
                    <span class="logo" style="color:white;font-size: 28px;">Handbook of Face Recognition (3rd Edition)</span>
                </div>
            </div> -->
        </div>
    </div>
    
    <div class="header-body" >
        <div style="margin:auto;text-align: center;">
            <div class="page-title" style="text-align: center;padding: 0">
                <span class="logo" style="color:white;font-size: 28px;">Handbook of Face Recognition (3rd Edition) <a href="d2l.html">d2l</a></span>
            </div>
        </div>
    </div>

</div>
<!-- end::header -->

<!-- begin::main -->
<div id="main">

    <!-- begin::navigation -->
    <div class="navigation" style="padding: 0">
        <div class="navigation-menu-body" style="font-size: 15px; font-weight: normal;color: #6a737d">
            <div class="navigation-menu-group">
                <div class="open"
                     id="dashboards">
                    <ul>
                        <li>
                            <a href="">Preface</a>
                        </li>
                        <li>
                            <a href="">Installation</a>
                        </li>
                        <li>
                            <a href="">Notation</a>
                        </li>
                        <li>
                            <a href="">I. Introduction and Background</a>
                            <ul>
                                <li>
                                    <a href="">1. Face Recognition Research and Development</a>
                                </li>
                                <li>
                                    <a href="">2. The Deep Neural Networks Approach to Face Recognition</a>
                                </li>
                            </ul>
                        </li>

                        <li>
                            <a href="">II. Fundamentals of Deep Neural Networks</a>
                            <ul>
                                <li>
                                    <a href="">3. Neural Network Architectures</a>
                                </li>
                                <li>
                                    <a href="">4. Generative Autoencoder Networks</a>
                                </li>
                                <li>
                                    <a href="">5. Generative Adversarial Networks</a>
                                </li>
                                <li>
                                    <a href="">6. Transfer Learning and Domain Adaptation</a>
                                </li>
                                <li>
                                    <a href="">7. Semi-supervised Learning</a>
                                </li>
                                <li>
                                    <a href="">8. Neural Network Model Compression and Acceleration</a>
                                </li>
                                <li>
                                    <a href="">9. Deep Learning Development Frameworks</a>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <a href="">III. Face Recognition by Deep Neural Networks</a>
                            <ul>
                                <li>
                                    <a href="">10. Face Detection</a>
                                </li>
                                <li>
                                    <a href="">11. Face Alignment</a>
                                </li>
                                <li>
                                    <a href="">12. Face Parsing</a>
                                </li>
                                <li>
                                    <a href="">13. 3D Face Landmarking and Morphing</a>
                                </li>
                                <li>
                                    <a href="">14. Face Similarity Metric Learning</a>
                                </li>
                                <li>
                                    <a href="">15. Face Feature Learning</a>
                                </li>
                                <li>
                                    <a href="">16. Pose Invariant Face Recognition</a>
                                </li>
                                <li>
                                    <a href="">17. Age Invariant Face Recognition</a>
                                </li>
                                <li>
                                    <a href="">18. 3D Face Recognition</a>
                                </li>
                                <li>
                                    <a href="">19. Heterogeneous Face Recognition</a>
                                </li>
                                <li>
                                    <a href="">20. Face Spoofing Detection</a>
                                </li>
                                <li>
                                    <a href="">21. Adversarial Face Perturbations</a>
                                </li>
                                <li>
                                    <a href="">22. Face Expression Recognition</a>
                                </li>
                                <li>
                                    <a href="">23. Face Attribute Recognition</a>
                                </li>
                                <li>
                                    <a href="">24. Multi-task Learning for Face Analysis</a>
                                </li>
                                <li>
                                    <a href="">25. Face Recognition in Video</a>
                                </li>
                                <li>
                                    <a href="">26. Face Super-resolution</a>
                                </li>
                                <li>
                                    <a href="">27. Face Data Augmentation</a>
                                </li>
                                <li>
                                    <a href="">28. Face Animation</a>
                                </li>
                                <li>
                                    <a href="">29. Explainable face recognition</a>
                                </li>
                                <li>
                                    <a href="">30. Bias in Face Recognition</a>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <a href="">IV. Face Recognition Systems</a>
                            <ul>
                <li>
                    <a href="">31. Face Unlock Systems</a>
                </li>
                <li>
                    <a href="">32. Large Scale Face Search Systems</a>
                </li>
                <li>
                    <a href="">33. Security and Privacy Protection</a>
                </li>
                <li>
                    <a href="">34. Database and Benchmarking</a>
                </li>
                <li>
                    <a href="">35. Face Recognition Standards</a>
                </li>
                <li>
                    <a href="">36. Government Regulations and Ethics</a>
                </li>
            </ul>
                        </li>
                        <li>
                            <a href="">Appendix. Open Source Data and Code</a>
                            <ul>
                                <li>
                                    <a href="">1. Open Source Data and Code: Overview</a>
                                </li>
                                <li>
                                    <a href="">2. Fundamentals of Deep Neural Networks</a>
                                </li>
                                <li>
                                    <a href="">3. Face Recognition by Deep Neural Networks</a>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <a href="https://github.com/FRH-Code-Data/Appendix/blob/master/References.md">References</a>
                            <ul>
                                <li>
                                    <a href="">Editors</a>
                                </li>
                                <li>
                                    <a href="">Contributions</a>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    <!-- end::navigation -->

    <div class="main-content">
        <div class="main">
            <div class="document" role="main" style="padding: 0 15%">
<h1>Naive Bayes</h1>
<p>:label:<code>sec_naive_bayes</code></p>
<p>Throughout the previous sections, we learned about the theory of probability and random variables.  To put this theory to work, let's introduce the <em>naive Bayes</em> classifier.  This uses nothing but probabilistic fundamentals to allow us to perform classification of digits.</p>
<p>Learning is all about making assumptions. If we want to classify a new data point that we have never seen before we have to make some assumptions about which data points are similar to each other. The naive Bayes classifier, a popular and remarkably clear algorithm, assumes all features are independent from each other to simplify the computation. In this section, we will apply this model to recognize characters in images.</p>
<pre><code class="language-{.python">%matplotlib inline
import d2l
import math
from mxnet import gluon, np, npx
npx.set_np()
d2l.use_svg_display()
</code></pre>
<h2>Optical Character Recognition</h2>
<p>MNIST :cite:<code>LeCun.Bottou.Bengio.ea.1998</code> is one of widely used datasets. It contains 60,000 images for training and 10,000 images for validation. Each image contains a handwritten digit from 0 to 9. The task is classifying each image into the corresponding digit.</p>
<p>Gluon provides a <code>MNIST</code> class in the <code>data.vision</code> module to
automatically retrieve the dataset from the Internet.
Subsequently, Gluon will use the already-downloaded local copy.
We specify whether we are requesting the training set or the test set
by setting the value of the parameter <code>train</code> to <code>True</code> or <code>False</code>, respectively.
Each image is a grayscale image with both width and height of $28$ with shape ($28$,$28$,$1$). We use a customized transformation to remove the last channel dimension. In addition, the dataset represents each pixel by an unsigned $8$-bit integer.  We quantize them into binary features to simplify the problem.</p>
<pre><code class="language-{.python">def transform(data, label):
    return np.floor(data.astype('float32') / 128).squeeze(axis=-1), label

mnist_train = gluon.data.vision.MNIST(train=True, transform=transform)
mnist_test = gluon.data.vision.MNIST(train=False, transform=transform)
</code></pre>
<p>We can access a particular example, which contains the image and the corresponding label.</p>
<pre><code class="language-{.python">image, label = mnist_train[2]
image.shape, label
</code></pre>
<p>Our example, stored here in the variable <code>image</code>, corresponds to an image with a height and width of $28$ pixels.</p>
<pre><code class="language-{.python">image.shape, image.dtype
</code></pre>
<p>Our code stores the label of each image as a scalar. Its type is a $32$-bit integer.</p>
<pre><code class="language-{.python">label, type(label), label.dtype
</code></pre>
<p>We can also access multiple examples at the same time.</p>
<pre><code class="language-{.python">images, labels = mnist_train[10:38]
images.shape, labels.shape
</code></pre>
<p>Let's visualize these examples.</p>
<pre><code class="language-{.python">d2l.show_images(images, 2, 9);
</code></pre>
<h2>The Probabilistic Model for Classification</h2>
<p>In a classification task, we map an example into a category. Here an example is a grayscale $28\times 28$ image, and a category is a digit. (Refer to :numref:<code>sec_softmax</code> for a more detailed explanation.)
One natural way to express the classification task is via the probabilistic question: what is the most likely label given the features (i.e., image pixels)? Denote by $\mathbf x\in\mathbb R^d$ the features of the example and $y\in\mathbb R$ the label. Here features are image pixels, where we can reshape a $2$-dimensional image to a vector so that $d=28^2=784$, and labels are digits.
The probability of the label given the features is $p(y  \mid  \mathbf{x})$. If we are able to compute these probabilities, which are $p(y  \mid  \mathbf{x})$ for $y=0, \ldots,9$ in our example, then the classifier will output the prediction $\hat{y}$ given by the expression:</p>
<p>$$\hat{y} = \mathrm{argmax} &gt; p(y  \mid  \mathbf{x}).$$</p>
<p>Unfortunately, this requires that we estimate $p(y  \mid  \mathbf{x})$ for every value of $\mathbf{x} = x_1, ..., x_d$. Imagine that each feature could take one of $2$ values. For example, the feature $x_1 = 1$ might signify that the word apple appears in a given document and $x_1 = 0$ would signify that it does not. If we had $30$ such binary features, that would mean that we need to be prepared to classify any of $2^{30}$ (over 1 billion!) possible values of the input vector $\mathbf{x}$.</p>
<p>Moreover, where is the learning? If we need to see every single possible example in order to predict the corresponding label then we are not really learning a pattern but just memorizing the dataset.</p>
<h2>The Naive Bayes Classifier</h2>
<p>Fortunately, by making some assumptions about conditional independence, we can introduce some inductive bias and build a model capable of generalizing from a comparatively modest selection of training examples. To begin, let's use Bayes theorem, to express the classifier as</p>
<p>$$\hat{y} = \mathrm{argmax}_y &gt; p(y  \mid  \mathbf{x}) = \mathrm{argmax}_y &gt; \frac{p( \mathbf{x}  \mid  y) p(y)}{p(\mathbf{x})}.$$</p>
<p>Note that the denominator is the normalizing term $p(\mathbf{x})$ which does not depend on the value of the label $y$. As a result, we only need to worry about comparing the numerator across different values of $y$. Even if calculating the denominator turned out to be intractable, we could get away with ignoring it, so long as we could evaluate the numerator. Fortunately, even if we wanted to recover the normalizing constant, we could.  We can always recover the normalization term since $\sum_y p(y  \mid  \mathbf{x}) = 1$.</p>
<p>Now, let's focus on $p( \mathbf{x}  \mid  y)$. Using the chain rule of probability, we can express the term $p( \mathbf{x}  \mid  y)$ as</p>
<p>$$p(x_1  \mid y) \cdot p(x_2  \mid  x_1, y) \cdot ... \cdot p( x_d  \mid  x_1, ..., x_{d-1}, y).$$</p>
<p>By itself, this expression does not get us any further. We still must estimate roughly $2^d$ parameters. However, if we assume that <em>the features are conditionally independent of each other, given the label</em>, then suddenly we are in much better shape, as this term simplifies to $\prod_i p(x_i  \mid  y)$, giving us the predictor</p>
<p>$$ \hat{y} = \mathrm{argmax}<em>y &gt; \prod</em>{i=1}^d p(x_i  \mid  y) p(y).$$</p>
<p>If we can estimate $\prod_i p(x_i=1  \mid  y)$ for every $i$ and $y$, and save its value in $P_{xy}[i, y]$, here $P_{xy}$ is a $d\times n$ matrix with $n$ being the number of classes and $y\in{1, \ldots, n}$. In addition, we estimate $p(y)$ for every $y$ and save it in $P_y[y]$, with $P_y$ a $n$-length vector. Then for any new example $\mathbf x$, we could compute</p>
<p>$$ \hat{y} = \mathrm{argmax}<em>y &gt; \prod_{i=1}^d P</em>{xy}[x_i, y]P_y[y],$$
:eqlabel:<code>eq_naive_bayes_estimation</code></p>
<p>for any $y$. So our assumption of conditional independence has taken the complexity of our model from an exponential dependence on the number of features $\mathcal{O}(2^dn)$ to a linear dependence, which is $\mathcal{O}(dn)$.</p>
<h2>Training</h2>
<p>The problem now is that we do not know $P_{xy}$ and $P_y$. So we need to estimate their values given some training data first. This is <em>training</em> the model. Estimating $P_y$ is not too hard. Since we are only dealing with $10$ classes, we may count the number of occurrences $n_y$ for each of the digits and divide it by the total amount of data $n$. For instance, if digit 8 occurs $n_8 = 5,800$ times and we have a total of $n = 60,000$ images, the probability estimate is $p(y=8) = 0.0967$.</p>
<pre><code class="language-{.python">X, Y = mnist_train[:]  # All training examples

n_y = np.zeros((10))
for y in range(10):
    n_y[y] = (Y == y).sum()
P_y = n_y / n_y.sum()
P_y
</code></pre>
<p>Now on to slightly more difficult things $P_{xy}$. Since we picked black and white images, $p(x_i  \mid  y)$ denotes the probability that pixel $i$ is switched on for class $y$. Just like before we can go and count the number of times $n_{iy}$ such that an event occurs and divide it by the total number of occurrences of $y$, i.e., $n_y$. But there is something slightly troubling: certain pixels may never be black (e.g., for well cropped images the corner pixels might always be white). A convenient way for statisticians to deal with this problem is to add pseudo counts to all occurrences. Hence, rather than $n_{iy}$ we use $n_{iy}+1$ and instead of $n_y$ we use $n_{y} + 1$. This is also called <em>Laplace Smoothing</em>.  It may seem ad-hoc, however it may be well motivated from a Bayesian point-of-view.</p>
<pre><code class="language-{.python">n_x = np.zeros((10, 28, 28))
for y in range(10):
    n_x[y] = np.array(X.asnumpy()[Y.asnumpy() == y].sum(axis=0))
P_xy = (n_x + 1) / (n_y + 1).reshape(10, 1, 1)

d2l.show_images(P_xy, 2, 5);
</code></pre>
<p>By visualizing these $10\times 28\times 28$ probabilities (for each pixel for each class) we could get some mean looking digits.</p>
<p>Now we can use :eqref:<code>eq_naive_bayes_estimation</code> to predict a new image. Given $\mathbf x$, the following functions computes $p(\mathbf x \mid y)p(y)$ for every $y$.</p>
<pre><code class="language-{.python">def bayes_pred(x):
    x = np.expand_dims(x, axis=0)  # (28, 28) -&gt; (1, 28, 28)
    p_xy = P_xy * x + (1 - P_xy)*(1 - x)
    p_xy = p_xy.reshape(10, -1).prod(axis=1)  # p(x|y)
    return np.array(p_xy) * P_y

image, label = mnist_test[0]
bayes_pred(image)
</code></pre>
<p>This went horribly wrong! To find out why, let's look at the per pixel probabilities. They are typically numbers between $0.001$ and $1$. We are multiplying $784$ of them. At this point it is worth mentioning that we are calculating these numbers on a computer, hence with a fixed range for the exponent. What happens is that we experience <em>numerical underflow</em>, i.e., multiplying all the small numbers leads to something even smaller until it is rounded down to zero.  We discussed this as a theoretical issue in :numref:<code>sec_maximum_likelihood</code>, but we see the phenomena clearly here in practice.</p>
<p>As discussed in that section, we fix this by use the fact that $\log a b = \log a + \log b$, i.e., we switch to summing logarithms.
Even if both $a$ and $b$ are small numbers, the logarithm values should be in a proper range.</p>
<pre><code class="language-{.python">a = 0.1
print('underflow:', a**784)
print('logarithm is normal:', 784*math.log(a))
</code></pre>
<p>Since the logarithm is an increasing function, we can rewrite :eqref:<code>eq_naive_bayes_estimation</code> as</p>
<p>$$ \hat{y} = \mathrm{argmax}<em>y &gt; \sum_{i=1}^d \log P</em>{xy}[x_i, y] + \log P_y[y].$$</p>
<p>We can implement the following stable version:</p>
<pre><code class="language-{.python">log_P_xy = np.log(P_xy)
log_P_xy_neg = np.log(1 - P_xy)
log_P_y = np.log(P_y)

def bayes_pred_stable(x):
    x = np.expand_dims(x, axis=0)  # (28, 28) -&gt; (1, 28, 28)
    p_xy = log_P_xy * x + log_P_xy_neg * (1 - x)
    p_xy = p_xy.reshape(10, -1).sum(axis=1)  # p(x|y)
    return p_xy + log_P_y

py = bayes_pred_stable(image)
py
</code></pre>
<p>We may now check if the prediction is correct.</p>
<pre><code class="language-{.python"># Convert label which is a scalar tensor of int32 dtype
# to a Python scalar integer for comparison
py.argmax(axis=0) == int(label)
</code></pre>
<p>If we now predict a few validation examples, we can see the Bayes
classifier works pretty well.</p>
<pre><code class="language-{.python">def predict(X):
    return [bayes_pred_stable(x).argmax(axis=0).astype(np.int32) for x in X]

X, y = mnist_test[:18]
preds = predict(X)
d2l.show_images(X, 2, 9, titles=[str(d) for d in preds]);
</code></pre>
<p>Finally, let's compute the overall accuracy of the classifier.</p>
<pre><code class="language-{.python">X, y = mnist_test[:]
preds = np.array(predict(X), dtype=np.int32)
float((preds == y).sum()) / len(y)  # Validation accuracy
</code></pre>
<p>Modern deep networks achieve error rates of less than $0.01$. The relatively poor performance is due to the incorrect statistical assumptions that we made in our model: we assumed that each and every pixel are <em>independently</em> generated, depending only on the label. This is clearly not how humans write digits, and this wrong assumption led to the downfall of our overly naive (Bayes) classifier.</p>
<h2>Summary</h2>
<ul>
<li>Using Bayes' rule, a classifier can be made by assuming all observed features are independent.</li>
<li>This classifier can be trained on a dataset by counting the number of occurrences of combinations of labels and pixel values.</li>
<li>This classifier was the gold standard for decades for tasks such as spam detection.</li>
</ul>
<h2>Exercises</h2>
<ol>
<li>Consider the dataset $[[0,0], [0,1], [1,0], [1,1]]$ with labels given by the XOR of the two elements $[0,1,1,0]$.  What are the probabilities for a Naive Bayes classifier built on this dataset.  Does it successfully classify our points?  If not, what assumptions are violated?</li>
<li>Suppose that we did not use Laplace smoothing when estimating probabilities and a data point arrived at testing time which contained a value never observed in training.  What would the model output?</li>
<li>The naive Bayes classifier is a specific example of a Bayesian network, where the dependence of random variables are encoded with a graph structure.  While the full theory is beyond the scope of this section (see :cite:<code>Koller.Friedman.2009</code> for full details), explain why allowing explicit dependence between the two input variables in the XOR model allows for the creation of a successful classifier.</li>
</ol>
<h2><a href="https://discuss.mxnet.io/t/5155">Discussions</a></h2>
<p><img src="/static/img/qr_naive-bayes.svg" alt="" /></p>
</div>
</div>


<!-- begin::footer -->
<footer style="margin-top:100%">
    <div class="container-fluid">
        <div>© 2020 Primex - <a href="" target="_blank">Laborasyon</a></div>
        <div>
            <nav class="nav">
                <a href="http://bootstrapmb.com/" class="nav-link">Licenses</a>
                <a href="#" class="nav-link">Change Log</a>
                <a href="#" class="nav-link">Get Help</a>
            </nav>
        </div>
    </div>
</footer>
<!-- end::footer -->

</div>
<!-- end::main-content -->

</div>
<!-- end::main -->

<!-- Plugin scripts -->
<script src="static/vendors/bundle.js"></script>


<!-- Slick -->
<script src="static/vendors/slick/slick.min.js"></script>

<!-- Chartjs -->
<script src="static/vendors/charts/chartjs/chart.min.js"></script>

<!-- Apex chart -->
<script src="https://apexcharts.com/samples/assets/irregular-data-series.js"></script>
<script src="static/vendors/charts/apex/apexcharts.min.js"></script>

<!-- Daterangepicker -->
<script src="static/vendors/datepicker/daterangepicker.js"></script>

<!-- DataTable -->
<script src="static/vendors/dataTable/datatables.min.js"></script>

<!-- Dashboard scripts -->
<script src="static/assets/js/examples/dashboard.js"></script>

<!-- To use theme colors with Javascript -->
<div class="colors">
<div class="bg-primary"></div>
<div class="bg-primary-bright"></div>
<div class="bg-secondary"></div>
<div class="bg-secondary-bright"></div>
<div class="bg-info"></div>
<div class="bg-info-bright"></div>
<div class="bg-success"></div>
<div class="bg-success-bright"></div>
<div class="bg-danger"></div>
<div class="bg-danger-bright"></div>
<div class="bg-warning"></div>
<div class="bg-warning-bright"></div>
</div>

<script>
$(function () {
$('.slick-js').slick({
    speed: 5,
    arrows: false,
    slidesToShow: 3,
    slidesToScroll: 1,
    autoplay: true,
    autoplaySpeed: 200,
    responsive: [
        {
            breakpoint: 992,
            settings: {
                slidesToShow: 3
            }
        },
        {
            breakpoint: 768,
            settings: {
                slidesToShow: 2
            }
        },
        {
            breakpoint: 500,
            settings: {
                slidesToShow: 1
            }
        }
    ]
});

$('input[name="daterangepicker"]').daterangepicker({
    opens: 'left'
});

$('.dataTable').DataTable({
    lengthMenu: [5, 10],
    "columnDefs": [{
        "targets": 7,
        "orderable": false
    }]
});
})
</script>


<!-- App scripts -->
<script src="static/assets/js/app.js"></script>

</body>
</html>
